I"<h2 id="1-your-first-database">1. Your first database</h2>

<p>데이터 베이스를 만드는 것은, csv나 excel파일을 이용하는 것보다 많은 이점을 가집니다.</p>

<p><br /></p>

<h4 id="a-relational-database">A relational database</h4>

<ul>
  <li>
    <p>데이터베이스는 개체를 테이블에 저장하여 모델링합니다. (professor, universities, companies)</p>
  </li>
  <li>
    <p>각 테이블에는 단일 항목 유형의 데이터만 포함됩니다. (Companies for bank “Credit Suisse”)</p>
  </li>
</ul>

<p>이것은 엔티티를 한 번만 저장하여 중복성을 줄입니다.</p>

<ul>
  <li>데이터베이스를 사용하여 엔티티 간의 관계를 모델링 할 수 있습니다. (교수는 대학, 회사 여러곳에서 일할 수 있고, 회사는 여러 교수를 고용할 수 있다.)</li>
</ul>

<p>이러한 구성을 통해, 엔티티가 서로 관련되는 방식을 정확히 정의할 수 있습니다.</p>

<p><br /></p>

<h4 id="have-a-look-at-the-postgresql-database">Have a look at the PostgreSQL database</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">table_schema</span><span class="p">,</span> <span class="k">table_name</span>
<span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">tables</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">table_name</span><span class="p">,</span> <span class="n">columns_name</span><span class="p">,</span> <span class="n">data_type</span>
<span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">columns</span>
<span class="k">WHERE</span> <span class="k">table_name</span> <span class="o">=</span> <span class="s1">'pg_config'</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> 
<span class="k">FROM</span> <span class="n">university_professors</span>
<span class="k">LIMIT</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="one-entity-type-in-the-database">One “entity type” in the database</h4>

<p align="center"><img src="/images/post_img/sql1.png" /></p>

<p>위와 같은 그림을 엔티티-관계 다이어그램이라고 합니다.</p>

<p>사각형은 소위 엔티티 유형을 나타내고, 연결된 원은 속성(또는 열)을 나타냅니다.</p>

<p align="center"><img src="/images/post_img/sql2.png" /></p>

<p>위와 같이 이용하면, 중복성이 줄어들게 됩니다. 하지만, 원래 속성 중 하나인 기능이 여전히 누락되어 있습니다. 이를 위해서 제휴 테이블을 따로 생성하는 것이 올바른 방법입니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="k">table_name</span><span class="p">(</span>
	<span class="n">column_a</span> <span class="n">data_type</span><span class="p">,</span>
	<span class="n">column_b</span> <span class="n">data_type</span><span class="p">,</span>
	<span class="n">column_c</span> <span class="n">data_type</span>
<span class="p">);</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">ADD</span> <span class="n">column_d</span> <span class="n">data_type</span><span class="p">;</span>
</code></pre></div></div>

<p>이를 위해 가장 먼저 해야하는 것은 테이블을 만드는 것입니다. 위와 같이, SQL의 CREATE TABLE 명령어를 사용합니다. 최소한 이 명령에는 테이블 이름과 해당 데이터 유형이 있는 하나 이상의 열이 필요합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">weather</span><span class="p">(</span>
	<span class="n">clouds</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">temperature</span> <span class="nb">numeric</span><span class="p">,</span>
	<span class="n">weather_station</span> <span class="nb">char</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<p>예를 들어, 적적할게 세 개의 열이 있는 날씨 테이블을 만들 수 있습니다.</p>

<p>각 열의 데이터 타입을 지정해야합니다.</p>

<p><br /></p>

<h4 id="distinct-data-in-the-new-tables">DISTINCT data in the new tables</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">university_professors</span><span class="p">;</span>
</code></pre></div></div>

<p>테이블을 분할하는 것의 한 가지 장점은 중복성이 감소된다는 것입니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">organization</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">university_professors</span><span class="p">;</span>
</code></pre></div></div>

<p>하지만 완벽하게, 고유의 조직으로 분리하지는 못합니다.</p>

<p><br /></p>

<h4 id="insert-distinct-records-into-the-new-tables">INSERT DISTINCT records INTO the new tables</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">organizations</span>
<span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">organization</span><span class="p">,</span>
	<span class="n">organization_sector</span>
<span class="k">FROM</span> <span class="n">university_professors</span><span class="p">;</span>
</code></pre></div></div>

<p>기존 테이블에서 새 테이블로 데이터를 복사하려면, INSERT INTO SELECT DISTINCT 패턴을 사용할 수 있습니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="nv">"value_a"</span><span class="p">,</span> <span class="nv">"value_b"</span><span class="p">);</span>
</code></pre></div></div>

<p>이것은 수동으로 값을 삽입하는 INSERT INTO 의 일반적인 사례입니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">affiliations</span><span class="p">(</span>
	<span class="n">first_name</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">last_name</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">university_shortname</span> <span class="nb">text</span><span class="p">,</span>
	<span class="k">function</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">organisation</span> <span class="nb">text</span>
<span class="p">);</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">RENAME</span> <span class="k">COLUMN</span> <span class="n">old_name</span> <span class="k">TO</span> <span class="n">new_name</span><span class="p">;</span>
</code></pre></div></div>

<p>column의 이름을 변경하고 싶으면, ALTER TABLE을 통해 변경할 수 있습니다.</p>

<p><br /></p>

<h4 id="drop-a-column-in-affiliations">DROP a column in affiliations</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">affiliations</span><span class="p">(</span>
	<span class="n">firstname</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">lastname</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">university_shortname</span> <span class="nb">text</span><span class="p">,</span>
	<span class="k">function</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">organization</span> <span class="nb">text</span>
<span class="p">);</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">DROP</span> <span class="k">COLUMN</span> <span class="k">column_name</span><span class="p">;</span>
</code></pre></div></div>

<p>university_shortname이 필요없기에, 이를 DROP 하기 위해서는 위와 같이 사용합니다.</p>

<p><br /></p>

<h2 id="2-enforce-data-consistency-with-attribute-constraints">2. Enforce data consistency with attribute constraints</h2>

<p><br /></p>

<p>데이터베이스 개념은 데이터를 특정 구조로 밀어 넣는 것입니다.</p>

<p>데이터 유형, 관계 및 기타 규칙을 적용하는 사전 정의된 모델입니다.</p>

<p>일반 적으로 이러한 규칙을 무결성 제약 조건이라고 하지만 다른 이름이 존재합니다.</p>

<p><br /></p>

<h4 id="integrity-constrains">Integrity constrains</h4>

<p>무결성 제약조건은 대략 세가지의 유형으로 나눌 수 있습니다.</p>

<ul>
  <li>Attribute constraints - 데이터 타입</li>
  <li>Key constraints -  고유키</li>
  <li>Referential integrity constraints - foreign keys</li>
</ul>

<p><br /></p>

<h4 id="why-constraints">Why constraints</h4>

<p>제약 조건에 대해 알아야하는 이유</p>

<ul>
  <li>데이터를 특정 형태로 압축</li>
  <li>제약 조건은 일관성을 제공</li>
  <li>데이터 품질 문제를 해결하는데 도움</li>
  <li>데이터베이스 관리 시스템에 큰 도움</li>
</ul>

<p><br /></p>

<h4 id="dealing-with-data-types-casting">Dealing with data types (casting)</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">weather</span> <span class="p">(</span>
	<span class="n">temperature</span> <span class="nb">integer</span><span class="p">,</span>
	<span class="n">wind_speed</span> <span class="nb">text</span>
<span class="p">);</span>
<span class="k">SELECT</span> <span class="n">temperature</span> <span class="o">*</span> <span class="n">wind_speed</span> <span class="k">AS</span> <span class="n">wind_chill</span>
<span class="k">FROM</span> <span class="n">weather</span><span class="p">;</span>
</code></pre></div></div>

<p>데이터 유형은, SQL 작업을 제한합니다. ( 텍스트 연산 등 )</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">temperature</span> <span class="o">*</span> <span class="k">CAST</span><span class="p">(</span><span class="n">wind_speed</span> <span class="k">AS</span> <span class="nb">integer</span><span class="p">)</span> <span class="k">AS</span> <span class="n">wind_chill</span>
<span class="k">FROM</span> <span class="n">weather</span><span class="p">;</span>
</code></pre></div></div>

<p>이를 위해서는, CAST를 이용합니다. ( 즉각적인 유형 변환 )</p>

<p><br /></p>

<h4 id="working-with-data-types">Working with data types</h4>

<p>데이터 유형 작업은 데이터베이스 관리 시스템에서 간단합니다.</p>

<ul>
  <li>테이블의 단일 열에 대해 구현됩니다.</li>
  <li>열에 있는 값의 영역을 정의합니다. (이러한 값이 취할 수 있는 형식과 그렇지 않은 형식)</li>
  <li>어떤 작업이 가능한지 정의합니다.</li>
  <li>일관된 저장이 이루어집니다.</li>
</ul>

<p>이러한 작업은 데이터 품질 향상에 도움이 됩니다.</p>

<p><br /></p>

<h4 id="the-most-common-types-postgresql">The most common types (PostgreSQL)</h4>

<ul>
  <li>text</li>
  <li>varchar(x)</li>
  <li>char(x)</li>
  <li>boolean</li>
  <li>date</li>
  <li>time</li>
  <li>timestamp</li>
  <li>numeric</li>
  <li>Integer</li>
</ul>

<p>데이터베이스 관리 시스템이 있으며 대부분의 SQL 표준을 따릅니다.</p>

<p><br /></p>

<h4 id="specifying-types-upon-table-creation">Specifying types upon table creation</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">students</span> <span class="p">(</span>
	<span class="n">ssn</span> <span class="nb">integer</span><span class="p">,</span>
	<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
	<span class="n">dob</span> <span class="nb">date</span><span class="p">,</span>
	<span class="n">average_grade</span> <span class="nb">numeric</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="c1">-- e.g. 5.24</span>
	<span class="n">tuition_paid</span> <span class="nb">boolean</span>
<span class="p">);</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">students</span>
<span class="k">ALTER</span> <span class="k">COLUMN</span> <span class="n">name</span>
<span class="k">TYPE</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
</code></pre></div></div>

<p>테이블 생성 후 유형을 변경하는 것은 위와 같습니다. ALTER COLUMN을 이용해서 지정합니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">students</span>
<span class="k">ALTER</span> <span class="k">COLUMN</span> <span class="n">average_grade</span>
<span class="k">TYPE</span> <span class="nb">integer</span>
<span class="c1">-- Turn 5.54 into 6, not 5, before type conversion</span>
<span class="k">USING</span> <span class="n">ROUND</span><span class="p">(</span><span class="n">average_grade</span><span class="p">)</span>
</code></pre></div></div>

<p>USING 키워드를 사용하서 유형이 변경되기전에 변환을 지정할 수 있습니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">professors</span> 
<span class="k">ALTER</span> <span class="k">COLUMN</span> <span class="n">firstname</span> 
<span class="k">TYPE</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> 
<span class="k">USING</span> <span class="k">SUBSTRING</span><span class="p">(</span><span class="n">firstname</span> <span class="k">FROM</span> <span class="mi">1</span> <span class="k">FOR</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="the-not-null-constraint">The not-null constraint</h4>

<ul>
  <li>NULL이 아닌 제약 조건은, 주어진 열에서 NULL 값을 허용하지 않습니다.</li>
  <li>이는 기존 상태 뿐만 아니라, 미래의 모든 상태에도 적용되어야 합니다.</li>
  <li>NULL 값을 보유하지 않은 열에 대해서만 not-null 제약 조건을 지정할 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="what-does-null-mean">What does NULL mean?</h4>

<ul>
  <li>unknown</li>
  <li>does not exist</li>
  <li>does not apply</li>
  <li>…</li>
</ul>

<p>&lt; br&gt;</p>

<h4 id="example">Example</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">students</span> <span class="p">(</span>
	<span class="n">ssn</span> <span class="nb">integer</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
	<span class="n">lastname</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
	<span class="n">home_phone</span> <span class="nb">integer</span><span class="p">,</span>
	<span class="n">office_home</span> <span class="nb">integer</span>
<span class="p">);</span>
</code></pre></div></div>

<p>위와 같이 학생을 정의하는 테이블이 있을 때, ssn(학생 고유번호), lastname는 null이 아니여야 하지만, home_phone이나 office_home등은 null을 허용해야합니다. (전화가 없을 수도 있기 때문에.)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">students</span>
<span class="k">ALTER</span> <span class="k">COLUMN</span> <span class="n">home_phone</span>
<span class="k">SET</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>그러나 기존 테이블에 null이 아닌 제약 조건을 추가하거나 제거할 수도 있습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">students</span>
<span class="k">ALTER</span> <span class="k">COLUMN</span> <span class="n">ssn</span>
<span class="k">DROP</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>비슷하게 not null을 해제할수도 있습니다.</p>

<p><br /></p>

<h4 id="the-unique-constraint">The unique constraint</h4>

<p>열에 대한 고유 제약조건은 열에 중복 항목이 없는지 확인합니다.</p>

<p>고유의 항목만 추가할 수 있습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="k">table_name</span><span class="p">(</span>
	<span class="k">column</span> <span class="n">name</span> <span class="k">UNIQUE</span>
<span class="p">);</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">some_name</span> <span class="k">UNIQUE</span><span class="p">(</span><span class="k">column_name</span><span class="p">)</span>
</code></pre></div></div>

<p>고유 제약 조건이 있는 열을 만드는 방법은 다음과 같습니다. 컬럼명 뒤에 UNIQUE 키워드를 추가하면 됩니다.</p>

<p>또한, 기존 테이블에 고유 제약 조건을 추가할 수도 있습니다.</p>

<p><br /></p>

<h2 id="3-uniquely-identify-records-with-key-constraints">3. Uniquely identify records with key constraints</h2>

<p><br /></p>

<h4 id="what-is-key">What is key?</h4>

<p>일반적으로 데이터베이스 테이블에는 속성 또는 다음의 조합이 있습니다.</p>

<ul>
  <li>
    <p>전체 테이블에서 고유한 여러 속성 (레코드를 고유하게 식별)</p>
  </li>
  <li>
    <p>슈퍼키 속성(조합을 제거할 수 있으며 속성은 여전히 레코드를 고유하개 식별)</p>
  </li>
  <li>
    <p>최소 키(최소한으로 구성)</p>
  </li>
</ul>

<p><br /></p>

<h4 id="primary-keys">Primary keys</h4>

<p>기본 키는 데이터베이스 설계에서 가장 중요한 개념 중 하나입니다.</p>

<ul>
  <li>
    <p>거의 모든 데이터베이스 테이블에는 후보 키 집합에서 사용자가 선택한 기본 키가 있어야 합니다.</p>
  </li>
  <li>
    <p>주요 목적은 테이블에서 레코드를 고유하게 식별하는 것입니다.</p>
  </li>
  <li>
    <p>기본 키는, 중복 또는 NULL값을 허용하지 않습니다.</p>
  </li>
  <li>
    <p>기본 키 제약조건은 시간 불변입니다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="specifying-primary-key">Specifying primary key</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">products</span> <span class="p">(</span>
	<span class="n">product_no</span> <span class="nb">integer</span> <span class="k">UNIQUE</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	<span class="n">name</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">price</span> <span class="nb">numeric</span>
<span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">products</span> <span class="p">(</span>
	<span class="n">product_no</span> <span class="nb">integer</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
	<span class="n">name</span> <span class="nb">text</span><span class="p">,</span>
	<span class="n">price</span> <span class="nb">numeric</span>
<span class="p">);</span>
</code></pre></div></div>

<p>위의 두 테이블은 동일한 데이터를 허용하지만, 두번째 테이블에서는 기본 키가 지정되어 있습니다.</p>

<p>기본키 지정방법은 뒤에 PRIMARY KEY를 지정해주면 됩니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">example</span> <span class="p">(</span>
	<span class="n">a</span> <span class="nb">integer</span><span class="p">,</span>
	<span class="n">b</span> <span class="nb">integer</span><span class="p">,</span>
	<span class="k">c</span> <span class="nb">integer</span><span class="p">,</span>
	<span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="k">c</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<p>둘 이상의 열을 기본 키로 지정하려는 경우 위와 같이 지정합니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">some_name</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="k">column_name</span><span class="p">)</span>
</code></pre></div></div>

<p>기존 테이블에 기본 키 제약 조건을 추가하는 것은 위와 같습니다.</p>

<p><br /></p>

<h4 id="surrogate-keys">Surrogate keys</h4>

<p>인공 대리 키를 만드는 이유</p>

<ul>
  <li>기본 키는 가능한 적은 수의 열로 이상적 구성</li>
  <li>기본 키는 시간이 지나도 변경되지 않아야 합니다.</li>
</ul>

<p><br /></p>

<h4 id="adding-a-surrogate-key-with-serial-data-type">Adding a surrogate key with serial data type</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cars</span>
<span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">id</span> <span class="nb">serial</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">;</span>
</code></pre></div></div>

<p>이를 다루는 특별한 유형이 있습니다.(serial)</p>

<p>Serial 타입은, 열을 추가하면 테이블의 모든 레코드에 번호가 매겨집니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">cars</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Opel'</span><span class="p">,</span> <span class="s1">'Astra'</span><span class="p">,</span> <span class="s1">'green'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>또한 이미 존재하는 ID를 지정하려고 하면 기본 키 제약 조건으로 인해 그렇지 못하게 합니다.</p>

<p><br /></p>

<h4 id="another-type-of-surrogate-key">Another type of surrogate key</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">column_c</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>

<span class="k">UPDATE</span> <span class="k">table_name</span>
<span class="k">SET</span> <span class="n">column_c</span> <span class="o">=</span> <span class="n">CONCAT</span><span class="p">(</span><span class="n">column_a</span><span class="p">,</span> <span class="n">column_b</span><span class="p">);</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">pk</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">column_c</span><span class="p">);</span>
</code></pre></div></div>

<p>대리 키를 만드는 또 다른 전략은 두 개의 기존 열을 이용해서 새 열을 만드는 방법입니다.</p>

<p><br /></p>

<h2 id="4-glue-together-tables-with-foreign-keys">4. Glue together tables with foreign keys</h2>

<p><br /></p>

<h4 id="implementing-relationships-with-foreign-keys">Implementing relationships with foreign keys</h4>

<p>외래 키는 다른 테이블의 기본 키를 가리키는 지정된 열입니다.</p>

<p>외래 키에는 몇가지 제한 사항이 있습니다.</p>

<ul>
  <li>도메인과 데이터 유형이 기본 키 중 하나와 동일해야 합니다.</li>
  <li>참조된 테이블의 기본 키에 값으로 존재하는 외래 키만 허용됩니다.</li>
  <li>참조 무결성이라고도 하는 실제 외래 키 제약 조건입니다.</li>
  <li>외래 키가 반드시 실제 키일 필요는 없습니다. ( 중복 or NULL 값 허용 )</li>
</ul>

<p><br /></p>

<h4 id="specifying-foreign-keys">Specifying foreign keys</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">manufacturers</span> <span class="p">(</span>
	<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">manufacturers</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Ford'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'VW'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'GM'</span><span class="p">);</span>

<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">cars</span> <span class="p">(</span>
	<span class="n">model</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">manufacturer_name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">manufactures</span> <span class="p">(</span><span class="n">name</span><span class="p">));</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">cars</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Ranger'</span><span class="p">,</span> <span class="s1">'Ford'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'Beetle'</span><span class="p">,</span> <span class="s1">'VW'</span><span class="p">)</span>
</code></pre></div></div>

<p>먼저 manufacturers라는 테이블과 , cars라는 테이블을 생성합니다.</p>

<p>자동차 테이블에는, REFERENCES를 이용해서 제조사 컬럼을 추가합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">cars</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Tundra'</span><span class="p">,</span> <span class="s1">'Toyota'</span><span class="p">);</span>
</code></pre></div></div>

<p>저장되지 않은, 제조사를 입력하면 테이블의 외래 키 제약 조건으로 인해 불가능합니다.</p>

<p><br /></p>

<h4 id="specifying-foreign-keys-to-existing-tables">Specifying foreign keys to existing tables</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">a</span>
<span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">a_fkey</span> <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">b_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">b</span> <span class="p">(</span><span class="n">id</span><span class="p">);</span>
</code></pre></div></div>

<p>기존 테이블에 외래 키를 추가하는 구문은 다음과 같습니다.</p>

<p>기본 키 및 고유 제약 조건을 추가하는 것과 동일합니다.</p>

<p><br /></p>

<h4 id="how-to-implement-nm---relationships">How to implement N:M - relationships</h4>

<ul>
  <li>테이블 만들기</li>
  <li>모든 테이블을 연결할 수 있는 외래 키</li>
  <li>추가 속성 포함</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">affiliations</span> <span class="p">(</span>
	<span class="n">professors_id</span> <span class="nb">integer</span> <span class="k">REFERENCES</span> <span class="n">professors</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="n">organization_id</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">organizations</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
	<span class="k">function</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<p>해당 관계 테이블을 처음부터 생성하려는 경우 표시된 대로 정의합니다.</p>

<ul>
  <li>기본 키가 정의되어 있지 않습니다.</li>
</ul>

<p><br /></p>

<h4 id="referential-integrity--참조-무결성-">Referential integrity ( 참조 무결성 )</h4>

<p>다른 테이블의 다른 레코드를 참조하는 레코드는 항상 기존 레코드를 참조해야 함을 나타냅니다.</p>

<p>즉, 테이블 A의 레코드는 존재하지 않는 테이블 B의 레코드를 가리킬 수 없습니다.</p>

<p>참조 무결성은 항상 두 개의 테이블과 관련된 제약 조건이며, 외래 키를 통해 적용됩니다.</p>

<p><br /></p>

<h4 id="referential-integrity-violations">Referential integrity violations</h4>

<p>참조 무결성은 두 가지 방식으로 위반 될 수 있습니다.</p>

<p>테이블 A가 테이블 B를 참조한다고 가정할 때,</p>

<ul>
  <li>테이블 A에서 이미 참조된 테이블 B의 레코드가 삭제되면 위반이 발생합니다.</li>
  <li>테이블 A에 테이블 B에 없는 것을 참조하는 레코드를 삽입하려고 하면 위반이 발생합니다.</li>
  <li>외래 키의 주된 이유 ( 외래 키가 오류를 발생시키고 실수로 이러한 작업을 수행하지 못하게 합니다. )</li>
</ul>

<p><br /></p>

<h4 id="dealing-with-violations">Dealing with violations</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">a</span> <span class="p">(</span>
	<span class="n">id</span> <span class="nb">integer</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
	<span class="n">column_a</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
	<span class="p">...</span>
	<span class="n">b_id</span> <span class="nb">integer</span> <span class="k">REFERENCES</span> <span class="n">b</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">NO</span> <span class="n">ACTION</span>
<span class="p">);</span>
</code></pre></div></div>

<p>열에 외래 키를 지정하면 실제로 데이터베이스 시스템이 삭제됬을 때,  ON DELETE NO ACTION 키워드는 자동으로 외래 키 정의에 추가됩니다.</p>

<p>즉, 테이블 B의 레코드를 삭제하려고 하면, 테이블 A에서 참조하는 경우 오류가 발생합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">a</span> <span class="p">(</span>
	<span class="n">id</span> <span class="nb">integer</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
	<span class="n">column_a</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
	<span class="p">...</span>
	<span class="n">b_id</span> <span class="nb">integer</span> <span class="k">REFERENCES</span> <span class="n">b</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span>
<span class="p">);</span>
</code></pre></div></div>

<p>CASCADE옵션을 사용하면, 테이블 B의 레코드를 선택한 다음 테이블 A의 모든 참조 레코드를 자동으로 삭제합니다. (계단식 삭제)</p>

<p><br /></p>

<h4 id="dealing-with-violations-1">Dealing with violations</h4>

<ul>
  <li>NO ACTION : 그냥 냅두기(에러발생)</li>
  <li>CASCADE : 참조 삭제 ( 계단식 삭제 )</li>
  <li>RESTRICT : 에러발생</li>
  <li>SET NULL : 레코드의 외래 키 값을 NULL로 설정</li>
  <li>SET DEFAULT : 열에 대한 기본값을 지정한 경우 작동하며, 디폴트값으로 변경</li>
</ul>

:ET