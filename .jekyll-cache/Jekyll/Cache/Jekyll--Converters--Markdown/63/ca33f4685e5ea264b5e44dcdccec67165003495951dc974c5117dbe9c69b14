I"<h1 id="database-design">Database Design</h1>

<h2 id="1-processing-storing-and-organizing-data">1. Processing, Storing, and Organizing Data</h2>

<p><br /></p>

<h4 id="데이터를-어떻게-구성하고-관리할까">데이터를 어떻게 구성하고 관리할까?</h4>

<ul>
  <li>Schemas</li>
  <li>Normalization</li>
  <li>Views</li>
  <li>Access control</li>
  <li>DBMS</li>
  <li>… and more</li>
</ul>

<p>어떻게 구성하냐에 따라, 가격이 다르고, 성능이 다르고, 메모리 차지하는 양이 다릅니다.</p>

<p>-&gt; 정답은 없으며, 데이터를 어떻게 사용하느냐에 따라 다릅니다.</p>

<p><br /></p>

<h4 id="oltp-vs-olap">OLTP vs OLAP</h4>

<p>OLTP와 OLAP는 데이터 처리에 대한 접근 방식입니다. 이는 데이터 흐름, 구조화 및 저장 방식을 정의하는데 도움이 됩니다.</p>

<p>비지니스 사례에 맞는 것이 무엇인지 파악하면 데이터베이스 설계가 휠씬 쉬워집니다.</p>

<p><br /></p>

<h4 id="oltp">OLTP</h4>

<ul>
  <li>Online Transcation Processing</li>
  <li>트랜잭션 중심</li>
</ul>

<h4 id="olap">OLAP</h4>

<ul>
  <li>Online Analytical Processing</li>
  <li>분석 중심</li>
</ul>

<p><br /></p>

<h4 id="서점의-예를-이용한-oltp-olap-비교">서점의 예를 이용한 OLTP, OLAP 비교</h4>

<h5 id="oltp-1">OLTP</h5>

<ul>
  <li>책의 가격을 찾는다.</li>
  <li>모든 고객 거래를 추적한다. ( 고객이 지불을 마칠 때 판매를 삽입하는 OLTP 접근 방식 )</li>
  <li>직원의 근무시간을 기록한다.</li>
</ul>

<h5 id="olap-1">OLAP</h5>

<ul>
  <li>가장 수익성이 높은 도서를 분석한다.</li>
  <li>충성 고객처럼 판매에 대한 정교한 분석을 수행한다.</li>
  <li>이달의 직원이 될 자격이 있는 사람에 대한 분석을 수행한다.</li>
</ul>

<p><br /></p>

<p>OLTP는 일상적인 작업을 지원하는데 중점을 두는 반면,</p>

<p>OLAP 작업은 모호하고 비지니스 의사 결정에 중점을 둡니다.</p>

<p><br /></p>

<h4 id="oltp-2">OLTP</h4>

<ul>
  <li>목적 : 데이터 처리를 돕는다</li>
  <li>디자인 : 애플리케이션 지향적</li>
  <li>데이터 : 아카이브되는 트랜잭션의 현재 스냅 샷</li>
  <li>사이즈 : 스냅샷 (기가바이트)</li>
  <li>쿼리 : 간단하고, 빠른 쿼리 또는 업데이트 필요</li>
  <li>유저 : 회사 전체에서 더 많은 사람들이 사용</li>
</ul>

<h4 id="olap-2">OLAP</h4>

<ul>
  <li>목적 : 데이터 분석을 돕는다.</li>
  <li>디자인 : 분석중인 특정 주제 중심</li>
  <li>데이터 : 장기 분석을 위해 통합 된 기간</li>
  <li>사이즈 : 아카이브 (테라바이트)</li>
  <li>쿼리 : 분석에 필요한 복잡한 쿼리 사용</li>
  <li>유저 : 분석가 및 데이터 과학자</li>
</ul>

<p><br /></p>

<p align="center"><img src="/images/post_img/design1.png" /></p>

<p>OLTP 및 OLAP 시스템은 함께 작동합니다. 그들은 서로를 필요 합니다.</p>

<p>OLTP 데이터는 일반적으로 OLAP 데이터웨어 하우스를 만들기 위해 가져 와서 정리되는 운영 데이터베이스에 저장됩니다.</p>

<p>트랜잭션 데이터가 없으면 분석을 수행 할 수 없습니다.</p>

<p>OLAP 시스템의 분석은 비지니스에 정보를 제공하는데 사용합니다. OLTP 데이터 베이스에 영향을 미칩니다.</p>

<p><br /></p>

<h4 id="takeaways">Takeaways</h4>

<ul>
  <li>비지니스 요구 사항을 파악</li>
  <li>OLAP or OLTP 접근 방식이 필요한지 파악</li>
</ul>

<p><br /></p>

<h4 id="데이터-구조">데이터 구조</h4>

<h5 id="1-structured-data">1. Structured data</h5>

<ul>
  <li>일반적으로 스키마에 의해 정의 되는 구조화 데이터</li>
  <li>데이터 유형, 테이블 정의, 관계 등 정의</li>
</ul>

<h5 id="2-unstructured-data">2. Unstructured data</h5>

<ul>
  <li>스키마가 없고, 가장 원시적인 형태의 데이터 ( 깨끗하지 않음 )</li>
  <li>Ex) 사진, 채팅로그, MP3파일 등</li>
</ul>

<h5 id="3-semi-structured-data">3. Semi-structured data</h5>

<ul>
  <li>더 큰 스키마보다는 임시 자체 설명 구조를 가지고 있습니다.</li>
  <li>일부 구조가 있습니다.</li>
  <li>Ex) NoSQL, XML, JSON</li>
</ul>

<p><br /></p>

<p align="center"><img src="/images/post_img/design2.png" /></p>

<p>깔끔하고 체계화 된 데이터는 분석하기 더 쉽습니다. 그러나 스키마를 따라야 하기 때문에 확장성이 떨어집니다.</p>

<p><br /></p>

<h4 id="전통-데이터-베이스">전통 데이터 베이스</h4>

<ul>
  <li>일반적으로 관계형 스키마를 따릅니다. ( OLTP에 사용되는 운영 데이터베이스 )</li>
  <li>데이터 분석이 시작되면 데이터 웨어하우스가 OLAP 접근 방식으로 대중화되었습니다.</li>
  <li>빅데이터 시대에 우리는 더 많은 데이터를 분석하고 저장해야 하는데 이를 데이터 레이크를 이용합니다.</li>
</ul>

<p><br /></p>

<h4 id="데이터-웨어하우스">데이터 웨어하우스</h4>

<ul>
  <li>읽기 전용 분석에 최적화 ( OLAP )</li>
  <li>여러 소스의 데이터를 결합하고 더 빠른 쿼리를 위해 대규모 병렬 처리</li>
  <li>일반적으로 차원 모델링과 비정규화 된 스키마를 사용합니다.</li>
  <li>AWS RED SHIFT, Azure SQL Data Warehouse, Google Big Query</li>
  <li>데이터 마트는, 특정 주제 전용 데이터 웨어하우스의 하위 집합입니다.</li>
  <li>데이터 마트를 사용하면 부서에서 중요한 데이터에 쉽게 액세스 가능합니다.</li>
</ul>

<p><br /></p>

<h4 id="데이터-레이크">데이터 레이크</h4>

<ul>
  <li>기술적으로 기존 데이터베이스 및 웨어하우스는 비정형 데이터를 저장 할 수는 있지만 비용적으로 효율적이지 않습니다.</li>
  <li>데이터 레이크 스토리지는 기존 블록 또는 파일 스토리지와 달리 개체 스토리지를 사용하기 때문에 더 저렴합니다. ( 대량의 데이터 저장 가능 )</li>
  <li>스트리밍 데이터에서 운영 데이터베이스에 이르기까지 모든 유형에 효과적으로 적용됩니다.</li>
  <li>데이터 레이크는 사용할 수 있는 모든 데이터를 저장합니다.</li>
  <li>비정형 데이터는 가장 확장성이 뛰어나기 때문에 거대한 크기의 데이터라도 허용합니다.</li>
  <li>데이터 레이크는 읽을 때, 스키마가 생성됩니다. (데이터 웨어하우스는 작성 시 스키마 분류)</li>
  <li>데이터 레이크는 잘 조직되고 분류되어야 합니다. (그렇지 않으면 데이터 늪이 됩니다.)</li>
  <li>데이터 레이크는 스토리지로 끝나지 않고, 분석을 실행하는 것도 인기를 얻고 있습니다. ( 딥러닝 및 데이터와 같은 작업  )</li>
</ul>

<p><br /></p>

<h4 id="etl">ETL</h4>

<ul>
  <li>Extract - Transform - Load</li>
  <li>데이터 웨어하우징 및 소규모 분석을 위한 전통적인 접근 방식</li>
</ul>

<p align="center"><img src="/images/post_img/design3.png" /></p>

<h4 id="elt">ELT</h4>

<ul>
  <li>Extract - Load - Transform</li>
  <li>ELT는 빅데이터 프로젝트에서 일반화 되었습니다.</li>
</ul>

<p align="center"><img src="/images/post_img/design4.png" /></p>

<p><br /></p>

<h4 id="데이터베이스-디자인이란">데이터베이스 디자인이란?</h4>

<p>데이터베이스 설계는 데이터가 논리적으로 저장되는 방식을 결정합니다.</p>

<p>이는 데이터 읽기 또는 데이터 업데이트 여부에 관계없이 데이터베이스 쿼리 방법에 영향을 미치기 때문에 중요합니다.</p>

<p>데이터 베이스 디자인에 필요한 두가지</p>

<ul>
  <li>데이터 베이스 모델 : 데이터베이스 구조에 대한 고급 사양, 가장 인기있는 관계형 모델은 관계형 데이터 베이스를 만드는데 사용</li>
  <li>스키마 : 데이터베이스의 청사진, 데이터베이스 모델의 구현, 특정 테이블, 필드, 관계, 인덱스 및 뷰를 정의하여 논리적 구조를 보다 세분화합니다. 구조화 된 데이터를 관계형 데이터베이스에 삽입 할 때 스키마를 준수해야 합니다.</li>
</ul>

<p><br /></p>

<h4 id="데이터-모델링">데이터 모델링</h4>

<p>데이터 베이스 설계의 첫 번째 단계는 데이터 모델링입니다. 이는, 저장 될 데이터에 대한 데이터 모델을 정의하는 추상 디자인 단계입니다.</p>

<ul>
  <li>개념적 데이터 모델 : 엔티티, 관계 및 속성과 같은 데이터베이스에 포함 된 내용</li>
  <li>논리적 데이터 모델 : 엔티티 관계가 테이블에 매핑되는 방식을 결정</li>
  <li>물리적 데이터 모델 : 데이터가 가장 낮은 추상화 수준에서 물리적으로 저장되는 방식을 살펴봄</li>
</ul>

<p>이러한 세가지 수준의 데이터 모델은 일관성을 보장하고 구현 및 사용 계획을 제공합니다.</p>

<p><br /></p>

<h4 id="차원-모델링">차원 모델링</h4>

<ul>
  <li>데이터 웨어 하우스를 위해 관계형 모델을 수정한 것</li>
  <li>업데이트보다는 분석을 목표로하는 OLAP 유형의 쿼리에 최적화 되어 있음</li>
  <li>스타 스키마를 사용</li>
  <li>차원 스카마는 해석 및 확장이 용이합니다.</li>
  <li>두 가지 유형의 테이블로 구성됩니다.
    <ul>
      <li>Fact tables
        <ul>
          <li>비지니스 사용 사례에 따라 결정</li>
          <li>주요 측정 항목으로 레코드가 포함되며, 측정 항목은 자주 변경됨</li>
          <li>차원 테이블에 대한 외래 키도 보유합니다.</li>
        </ul>
      </li>
      <li>Dimension tables
        <ul>
          <li>특정 속성에 대한 설명을 보유하며 자주 변경되지 않습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="2-database-schemas-and-normalization">2. Database Schemas and Normalization</h2>

<p><br /></p>

<h4 id="star-schema">Star schema</h4>

<p>스타 스키마는 차원 모델의 가장 단순한 형태입니다. ( 일부는 스타 스키마와 차원 모델링 이라는 용어를 같은 의미로 사용합니다. )</p>

<p align="center"><img src="/images/post_img/design5.png" /></p>

<p>기본 및 외래 키를 제외하고 팩트 테이블에는 판매 금액과 책 수량이 포함됩니다.</p>

<p>위 테이블 구조는 일대 다 관계입니다. 스타 스키마는 위의 테이블처럼 확장 점이 다른 별처럼 보이기에 이러한 이름을 얻었습니다.</p>

<p><br /></p>

<h4 id="snowflake-schema">Snowflake schema</h4>

<p align="center"><img src="/images/post_img/design6.png" /></p>

<p>스노우플레이크 스키마는 스타스키마의 확장입니다. 스노우플레이크 스키마는 1차원 보다 큰데, 이는 차원테이블이 정규화(Normalized) 되었기 때문입니다.</p>

<p><br /></p>

<h4 id="normalization">Normalization?</h4>

<p>정규화는 테이블을 더 작은 테이블로 나누고 관계를 통해 연결하는 기술입니다.</p>

<p>중복성을 줄이고, 데이터 무결성을 높이는 것을 목표로합니다.</p>

<ul>
  <li>반복되는 그룹을 식별하고 이를 위한 새 테이블을 만들어서 정규화를 진행합니다.</li>
</ul>

<p><br /></p>

<h4 id="정규화-예시">정규화 예시</h4>

<p align="center"><img src="/images/post_img/design7.png" /></p>

<p>다음 테이블이 있을 때, Author, Publisher, Genre는 중복이 될 수 있으므로, 새 테이블을 만들 수 있습니다.</p>

<p align="center"><img src="/images/post_img/design8.png" /></p>

<p>이를 정규화하면 다음과 같은 테이블 구조를 가지게 됩니다.</p>

<p align="center"><img src="/images/post_img/design9.png" /></p>

<p>다른 예시로 다음을 정규화 한다면,</p>

<p align="center"><img src="/images/post_img/design10.png" /></p>

<p>이는 위의 스타 스키마와 다른 모습을 보입니다.</p>

<p><br /></p>

<h4 id="book-store-example">book store example</h4>

<p>Octavia E 버틀러의 2018년 4분기 밴쿠버 모든 책의 판매수량을 알고 싶다고 가정할 때,</p>

<p><br /></p>

<h4 id="비정규화-쿼리">비정규화 쿼리</h4>

<p>비정규화 된 스키마를 쿼리를 실행하면 이를 수행할 수 있습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">fact_booksales</span>
<span class="c1">-- Join to get city</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_store_star</span> <span class="k">on</span> <span class="n">fact_booksales</span><span class="p">.</span><span class="n">store_id</span> <span class="o">=</span> <span class="n">dim_store_star</span><span class="p">.</span><span class="n">store_id</span>
<span class="c1">-- Join to get author</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_book_star</span> <span class="k">on</span> <span class="n">fact_booksales</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">dim_book_star</span><span class="p">.</span><span class="n">book_id</span>
<span class="c1">-- Join to get year and quarter</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_time_star</span> <span class="k">on</span> <span class="n">fact_booksales</span><span class="p">.</span><span class="n">time_id</span> <span class="o">=</span> <span class="n">dim_time_star</span><span class="p">.</span><span class="n">time_id</span>
<span class="k">WHERE</span>    
<span class="n">dim_store_star</span><span class="p">.</span><span class="n">city</span> <span class="o">=</span> <span class="s1">'Vancouver'</span>	<span class="k">AND</span> <span class="n">dim_book_star</span><span class="p">.</span><span class="n">author</span> <span class="o">=</span> <span class="s1">'Octavia E. Butler'</span>	<span class="k">AND</span>    
<span class="n">dim_time_star</span><span class="p">.</span><span class="nb">year</span> <span class="o">=</span> <span class="mi">2018</span>	<span class="k">AND</span> <span class="n">dim_time_star</span><span class="p">.</span><span class="n">quarter</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="정규화된-쿼리">정규화된 쿼리</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">SUM</span><span class="p">(</span><span class="n">fact_booksales</span><span class="p">.</span><span class="n">quantity</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">fact_booksales</span>
<span class="c1">-- Join to get city</span>
<span class="k">INNER</span>	<span class="k">JOIN</span> <span class="n">dim_store_sf</span> <span class="k">ON</span> <span class="n">fact_booksales</span><span class="p">.</span><span class="n">store_id</span> <span class="o">=</span> <span class="n">dim_store_sf</span><span class="p">.</span><span class="n">store_idINNERJOIN</span> <span class="n">dim_city</span> <span class="k">ON</span> <span class="n">dim_store_sf</span><span class="p">.</span><span class="n">city_id</span> <span class="o">=</span> <span class="n">dim_city_sf</span><span class="p">.</span><span class="n">city_id</span>
<span class="c1">-- Join to get author</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_book_sf</span> <span class="k">ON</span> <span class="n">fact_booksales</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">dim_book_sf</span><span class="p">.</span><span class="n">book_id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_author_sf</span> <span class="k">ON</span> <span class="n">dim_book_sf</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">dim_author_sf</span><span class="p">.</span><span class="n">author_id</span>
<span class="c1">-- Join to get year and quarter</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_time_sf</span> <span class="k">ON</span> <span class="n">fact_booksales</span><span class="p">.</span><span class="n">time_id</span> <span class="o">=</span> <span class="n">dim_time_sf</span><span class="p">.</span><span class="n">time_id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_month_sf</span> <span class="k">ON</span> <span class="n">dim_time_sf</span><span class="p">.</span><span class="n">month_id</span> <span class="o">=</span> <span class="n">dim_month_sf</span><span class="p">.</span><span class="n">month_id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_quarter_sf</span> <span class="k">ON</span> <span class="n">dim_month_sf</span><span class="p">.</span><span class="n">quarter_id</span> <span class="o">=</span>  <span class="n">dim_quarter_sf</span><span class="p">.</span><span class="n">quarter_id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">dim_year_sf</span> <span class="k">ON</span> <span class="n">dim_quarter_sf</span><span class="p">.</span><span class="n">year_id</span> <span class="o">=</span> <span class="n">dim_year_sf</span><span class="p">.</span><span class="n">year_id</span>
<span class="k">WHERE</span>  <span class="n">dim_city_sf</span><span class="p">.</span><span class="n">city</span> <span class="o">=</span> <span class="nv">`Vancouver`</span>  <span class="k">AND</span>   <span class="n">dim_author_sf</span><span class="p">.</span><span class="n">author</span> <span class="o">=</span> <span class="nv">`Octavia E. Butler`</span>  <span class="k">AND</span>  <span class="n">dim_year_sf</span><span class="p">.</span><span class="nb">year</span> <span class="o">=</span> <span class="mi">2018</span> <span class="k">AND</span> <span class="n">dim_quarter_sf</span><span class="p">.</span><span class="n">quarter</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div></div>

<p>정규화된 쿼리를 사용할때는, 더 오래걸립니다. 이는 더 많은 테이블을 조인하므로 더 느려집니다.</p>

<p><br /></p>

<h4 id="정규화-하는-이유">정규화 하는 이유</h4>

<p>정규화는 위의 사례처럼 쿼리도 길어지고, 연산도 많아지지만, 사용하는 이유는 공간을 절약하기 때문입니다.</p>

<p>정규화 된 데이터베이스에 더 많은 테이블이 있는 방식은 보는 것에도 직관적이 않습니다.</p>

<p align="center"><img src="/images/post_img/design11.png" /></p>

<p align="center"><img src="/images/post_img/design12.png" /></p>

<p>정규화된 테이블 위와 같이 직관적이지 않습니다. 하지만 이를 통해서 중복되는 데이터를 제거할 수 있습니다.</p>

<p><br /></p>

<h4 id="정규화는-설계를-통해-더-나은-데이터-무결성-보장합니다">정규화는 설계를 통해 더 나은 데이터 무결성 보장합니다.</h4>

<p>무결성 : 데이터의 정확성과 일관성을 유지하고, 데이터에 결손과 부정합이 없음을 보증</p>

<ul>
  <li>데이터의 일관성을 유지합니다. ( 데이터 입력은 지저분해 질 수 있으며 때때로 사람들은 필드를 다르게 채울 것 입니다. - California or CA )</li>
  <li>중복이 줄어들 기 때문에 데이터 수정이 더 안전하고 간단해집니다.</li>
  <li>테이블이 더 작고, 개체별로 더 많이 구성되므로 데이터베이스 스키마를 변경하기 더 쉽습니다.</li>
</ul>

<p><br /></p>

<h4 id="데이터-정규화-장단점">데이터 정규화 장단점</h4>

<h5 id="장점">장점</h5>

<ul>
  <li>데이터베이스 유지 관리에 매력적</li>
</ul>

<h5 id="단점">단점</h5>

<ul>
  <li>정규화에는 쿼리를 만드는 더 많은 조인이 필요 ( 더 복잡하여 인덱싱 및 데이터 읽기 속도가 느려질 수 있습니다. )</li>
</ul>

<p><br /></p>

<h4 id="oltp-and-olap">OLTP and OLAP</h4>

<p>OLTP는 쓰기 집약적인 의미로 자주 업데이트하고 작성합니다. 정규화는 데이터를 빠르고 일관되게 추가하기를 원하기 때문에 의미있습니다.</p>

<p>OLAP는 데이터에 대한 분석을 실행하기 때문에 읽기 집약적입니다. 즉 더 빠른 읽기 쿼리와 우선 순위를 지정하고 싶습니다.</p>

<p><br /></p>

<h4 id="normalization-1">Normalization</h4>

<p>반복된 데이터 그룹을 찾아서 그룹에 대한 새 테이블 만들기</p>

<ul>
  <li>정규화의 목표
    <ul>
      <li>관계형 스키마에서 중복 수준을 줄일 수 있다.</li>
      <li>스키마 처리단계에서, 중복을 제거하는 메카니즘을 제공한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="normal-form-nf">Normal form (NF)</h4>

<p>정규화 할 수 있는 범위는 다양합니다.  이를 작은 것부터 큰 것까지 정규화 할 수 있습니다.</p>

<p align="center"><img src="/images/post_img/design13.png" /></p>

<h4 id="1nf-rules">1NF rules</h4>

<ul>
  <li>1NF를 준수하려면 각 레코드가 고유해야하며, 각 셀은 하나의 값을 보유해야합니다.</li>
</ul>

<p align="center"><img src="/images/post_img/design14.png" /></p>

<p>모든 행은 고유하지만, course_completed열에는 두 개의 레코드에 둘 이상의 코스가 있습니다. 이를 수정하기 위해서 테이블을 아래와 같이 분할 할 수 있습니다.</p>

<p align="center"><img src="/images/post_img/design15.png" /></p>

<p>위와 같이 설정하면, 모든 레코드가 고유하고 각 열에 하나의 값이 있습니다.</p>

<p><br /></p>

<h4 id="2nf">2NF</h4>

<ul>
  <li>2NF 는 1NF를 만족해야합니다.</li>
  <li>그 외에도 기본 키가 하나의 열이면 테이블은 2NF입니다.</li>
  <li>테이블에 복합 키 ( 기본 키가 둘 이상의 열로 구성된 경우 ) 가 있는 경우 키가 아닌 각 열은 모든 키에 종속되어야합니다.</li>
</ul>

<p align="center"><img src="/images/post_img/design16.png" /></p>

<p>위의 테이블은 합성 기본 키로 학생아이디와, 코스아이디가 있습니다. 이후 다른 열과 이 두 키에 대한 종속성을 검토합니다.</p>

<p align="center"><img src="/images/post_img/design17.png" /></p>

<p>이를 2NF로 변경하기 위해서는, 두개의 새 테이블로 분할합니다.</p>

<p><br /></p>

<h4 id="3nf">3NF</h4>

<ul>
  <li>3NF는 2NF를 충족해야 합니다.</li>
  <li>3NF는 종속성을 허용하지 않습니다. 즉, 기본 키가 아닌 열은 다른 기본 키가 아닌 열에 의존 할 수 없습니다.</li>
</ul>

<p align="center"><img src="/images/post_img/design18.png" /></p>

<p align="center"><img src="/images/post_img/design19.png" /></p>

<p>위의 테이블을 이용하면, 종속성이 없으며, 복합 기본 키가 없기 때문에 2NF를 충족합니다.</p>

<p><br /></p>

<h4 id="data-anomalies">Data anomalies</h4>

<p>충분히 정규화되지 않은 데이터베이스는 업데이트, 삽입 및 삭제라는 세 가지 유형의 이상 오류가 발생하기 쉽습니다.</p>

<ul>
  <li>Update anomaly
    <ul>
      <li>업데이트 이상은 중복으로 데이터베이스를 업데이트 할 때 발생할수 있는 데이터 불일치입니다.</li>
      <li>확장함에 따라 이러한 중복은 추적하기 더 어렵습니다.</li>
    </ul>
  </li>
  <li>Insert anomaly
    <ul>
      <li>삽입 이상은 속성 누락으로 인해 새 레코드를 추가 할 수 없는 경우입니다.</li>
      <li>동일한 테이블에있는 열 간의 종속성은 의도하지 않게 테이블에 삽입 할 수 있는 항목을 제한합니다.</li>
    </ul>
  </li>
  <li>Deletion anomaly
    <ul>
      <li>레코드를 삭제하고 다른 데이터를 삭제하면 삭제 이상이 발생합니다.</li>
    </ul>
  </li>
</ul>

<p>데이터 베이스가 정규화 될수록 이러한 문제가 발생할 가능성이 줄어 듭니다.</p>

<p>대부분의 3NF 테이블에는 업데이트, 삽입 및 삭제 이상이 있을 수 없습니다.</p>

<p><br /></p>

<h2 id="3-database-views">3. Database Views</h2>

<p><br /></p>

<h4 id="database-views">Database views</h4>

<p>데이터 베이스에서, 원하는 모든 데이터를 선택하여, 그들을 사용자 정의하여 나타낸 것이다. 관계형 데이터베이스의 관계 모델의 관계의 일종인 도출 관계에 해당하며, 여러 테이블 또는 뷰의 데이터를 연결하여 조합할 수 있다.</p>

<ul>
  <li>기본적으로 뷰는 물리적 스키마의 일부가 아닌 가상 테이블입니다.</li>
  <li>뷰는 실제 메모리에 저장되지 않습니다.</li>
  <li>뷰의 데이터는 동일한 데이터베이스의 테이블에있는 데이터에서 가져옵니다.</li>
  <li>뷰가 형성되면 일반 테이블처럼 쿼리 할 수 있습니다.</li>
  <li>뷰의 장점은, 일반적인 쿼리를 다시 입력 할 필요가 없다는 것입니다.</li>
  <li>데이터베이스의 스키마를 변경하지 않고 가상 테이블을 추가 할 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="creating-a-view">Creating a view</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">view_name</span> <span class="k">AS</span>

<span class="k">SELECT</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span>
<span class="k">FROM</span> <span class="k">table_name</span>
<span class="k">WHERE</span> <span class="n">condition</span><span class="p">;</span>
</code></pre></div></div>

<p>쿼리를 가져와 그 앞에 행을 추가하여 뷰 이름을 지정합니다.</p>

<p><br /></p>

<h4 id="creating-a-view-example">Creating a View (example)</h4>

<p align="center"><img src="/images/post_img/design20.png" /></p>

<p>회사의 분석가가 종종 공상과학 장르에 대한 분석을 실행한다고 가정</p>

<p>워크 플로를 돕기 위해, 특별히 뷰를 반들고 싶습니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">scifi_books</span> <span class="k">AS</span>

<span class="k">SELECT</span> <span class="n">title</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="n">genre</span>
<span class="k">FROM</span> <span class="n">dim_book_sf</span>
<span class="k">JOIN</span> <span class="n">dim_genre_sf</span> <span class="k">ON</span> <span class="n">dim_genre_sf</span><span class="p">.</span><span class="n">genre_id</span> <span class="o">=</span> <span class="n">dim_book_sf</span><span class="p">.</span><span class="n">genre_id</span>
<span class="k">JOIN</span> <span class="n">dim_author_sf</span> <span class="k">ON</span> <span class="n">dim_author_sf</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">dim_book_sf</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">WHERE</span> <span class="n">dim_genre_sf</span><span class="p">.</span><span class="n">genre</span> <span class="o">=</span> <span class="s1">'science fiction'</span>
</code></pre></div></div>

<p>위의 코드를 실행한 뒤, 뷰를 쿼리할 수 있습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">scifi_books</span>
</code></pre></div></div>

<p>뷰를 통해 생성된 테이블은 실제 메모리가 있는 테이블이 아닙니다.</p>

<p><br /></p>

<h4 id="viewing-biews">Viewing biews</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">INFORMATION_SCHEMA</span><span class="p">.</span><span class="n">views</span><span class="p">;</span>
</code></pre></div></div>

<p>데이터베이스에서 뷰를 추적하는 것은 중요합니다. 데이터베이스의 모든 뷰를 가져 오려면 INFORMATION_SCHEMA에서 쿼리를 실행할 수 있습니다. (PostgreSQL)</p>

<p>이를 실행하면 많은 뷰들이 보이는데, DBMS에 내장되어 있는 뷰들이 있기에 그렇습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">views</span>
<span class="k">WHERE</span> <span class="n">table_schema</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'pg_catalog'</span><span class="p">,</span> <span class="s1">'information_schema'</span><span class="p">)</span>
</code></pre></div></div>

<p>시스템뷰를 제외하고 생성한 뷰를 가져 오려면 위의 쿼리를 사용합니다.</p>

<p><br /></p>

<h4 id="view의-장점">View의 장점</h4>

<ul>
  <li>최소한의 쿼리 문을 제외하고는 어떤 스토리지도 차지하지 않습니다.</li>
  <li>액세스 제어의 한 형태로 작동 ( 사용자에게 액세스 권한을 부여하는 대신, 민감한 정보가 있을 수 있는 열에 대해서는 뷰를 통해 볼 수 있는 내용을 제한 할 수 있습니다. )</li>
  <li>쿼리의 복잡성을 감춥니다.</li>
</ul>

<p><br /></p>

<h4 id="creating-moe-complex-views">Creating moe complex views</h4>

<p>뷰는 선택한 만큼 복잡하고 창의적일 수 있다는 점을 알아야합니다.</p>

<p align="center"><img src="/images/post_img/design21.png" /></p>

<p>물론 사용한 함수만큼, 뷰를 불러오는 시간이 길어진다는 것은 알아야합니다.</p>

<p><br /></p>

<h4 id="grating-and-revoking-access-to-a-view">Grating and revoking access to a view</h4>

<ul>
  <li>사용자 권한을 부여하고 제거하기 위해 SQL GRANT 및 REVOKE명령을 사용합니다.</li>
</ul>

<ol>
  <li>먼저 GRANT 및 REVOKE 명령 뒤에 관련 권한을 나열합니다.</li>
</ol>

<p>Privileges : SELECT, INSERT, UPDATE, DELETE, etc</p>

<ol>
  <li>
    <p>그 이후, 개체와 역할을 지정합니다.</p>
  </li>
  <li>
    <p>부여 및 취소에 각각 To절과 FROM절을 사용합니다.</p>
  </li>
</ol>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="k">UPDATE</span> <span class="k">ON</span> <span class="n">ratings</span> <span class="k">TO</span> <span class="k">PUBLIC</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">REVOKE</span> <span class="k">INSERT</span> <span class="k">ON</span> <span class="n">films</span> <span class="k">FROM</span> <span class="n">db_users</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="updating-a-view">Updating a view</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">films</span> <span class="k">SET</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">'Dramatic'</span> <span class="k">WHERE</span> <span class="n">kind</span> <span class="o">=</span> <span class="s1">'Drama'</span><span class="p">;</span>
</code></pre></div></div>

<p>사용자는 필요한 권한이 있는 경우 뷰를 업데이트 할 수 있습니다.</p>

<h5 id="하지만-실제-테이블이-아닌데-어떻게-">하지만 실제 테이블이 아닌데 어떻게 ?</h5>

<p>업데이트를 실행 할 때, 뷰 뒤에서 테이블을 업데이트합니다.</p>

<p>따라서, 특정 뷰만 업데이트 할 수 있습니다. 업데이트 가능한 기준이 있는데, 이 기준은 사용중인 SQL 유형을 따릅니다.</p>

<p>일반적으로 뷰는 하나의 테이블로 구성되어야하며, window or aggregate 함수에 의존 할 수 없습니다.</p>

<p><br /></p>

<h4 id="inserting-into-a-view">Inserting into a view</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">films</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">date_prod</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="s1">'T_601'</span><span class="p">,</span> <span class="s1">'Yojimbo'</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="s1">'1961-06-16'</span><span class="p">,</span> <span class="s1">'Drama'</span><span class="p">)</span>
</code></pre></div></div>

<p>Insert 명령은 Update 명령과 유사합니다. 뷰에 Insert 명령을 실행하면, 실제로 그 뒤에있는 테이블에 삽입합니다.</p>

<ul>
  <li>일반적으로 뷰를 통해 데이터를 수정하지 마세요. 읽기 전용 목적으로만 사용하는 것이 좋습니다.</li>
</ul>

<p><br /></p>

<h4 id="dropping-a-view">Dropping a view</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">VIEW</span> <span class="n">view_name</span> <span class="p">[</span> <span class="k">CASCADE</span> <span class="o">|</span> <span class="k">RESTRICT</span> <span class="p">];</span>
</code></pre></div></div>

<p>Drop 명령을 위해 알아야하는 것으로 CASCADE와 RESTRICT가 있습니다.</p>

<p>뷰가 더 큰 데이터베이스의 다른 뷰에 의해 빌드되는 것은 흔한일인데,</p>

<ul>
  <li>RESTRICT 매개 변수는 기본값으로, 다른 오브젝트가 의존하는 뷰를 삭제하려고하면 오류를 리턴합니다.</li>
  <li>CASCADE 매개 변수는 뷰와 연결된 모든 개체를 삭제합니다.</li>
</ul>

<p><br /></p>

<h4 id="redefining-a-view">Redefining a view</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">VIEW</span> <span class="n">view_name</span> <span class="k">AS</span> <span class="n">new_query</span>
</code></pre></div></div>

<p>뷰가 정의된 쿼리를 변경하고 싶다고 가정하면, 이를 위해 CREATE OR REPLACE 명령을 사용합니다.</p>

<p>view_name이 존재하면 지정된 new_query로 대체됩니다.</p>

<p>제한사항 - 새 쿼리는 기존 쿼리와 동일한 열 이름, 열 순서 및 열 데이터 형식을 생성해야합니다. 해당 조건이 충족되는 한 열 출력은 다를 수 있습니다.</p>

<p>위 조건을 충족하면 마지막에 새 열이 추가 될 수 있습니다. 이러한 조건을 충족하지 못한다면, 기존 뷰를 삭제하고 새 뷰를 만드는 것이 좋습니다.</p>

<p><br /></p>

<h4 id="altering-a-view">Altering a view</h4>

<p>보조 속성을 변경 할 수 있습니다.</p>

<p align="center"><img src="/images/post_img/design22.png" /></p>

<p><br /></p>

<h4 id="두개의-view-타입">두개의 View 타입</h4>

<ul>
  <li>비 구체화 뷰</li>
  <li>구체화된 뷰</li>
</ul>

<p>뷰라는 용어는 명확하게 접하면, 비 구체화 뷰를 가르킬 가능성이 큽니다.</p>

<h5 id="materialized-views--구체화된-뷰-">Materialized views ( 구체화된 뷰 )</h5>

<ul>
  <li>
    <p>구체화된 뷰는 물리적으로 구체화 된 반면 비 구체화 된 뷰는 가상 상태로 유지됩니다.</p>
  </li>
  <li>
    <p>비 구체화된 뷰는 질의를 저장하는 대신 구체화 된 뷰는 결과를 저장합니다.</p>
  </li>
  <li>
    <p>이러한 쿼리 결과는 디스크에 저장됩니다.</p>
  </li>
  <li>이것은 쿼리가 뷰를 통해 미리 계산된다는 것을 의미합니다.</li>
  <li>구체화 된 뷰는 프롬프트가 표시되면 새로 고쳐 지거나 다시 구체화됩니다.</li>
  <li>새로 고치거나 재 구체화하면 쿼리가 실행되고 저장된 쿼리 결과가 업데이트됩니다.</li>
</ul>

<p><br /></p>

<h4 id="구체화된-뷰를-사용하면-좋은-경우">구체화된 뷰를 사용하면 좋은 경우</h4>

<ul>
  <li>실행 시간이 긴 쿼리가 있는 경우 구체화 된 뷰가 좋습니다. ( 데이터가 마지막 뷰를 고쳤을 때, 최신 상태 )</li>
  <li>따라서 자주 업데이트되는 데이터는 오래된 데이터에 대해 분석이 자주 실행되기 때문에 구체화된 뷰를 사용하면 안됩니다.</li>
  <li>구체화 된 뷰는 데이터 웨어 하우스에서 유용합니다. ( 분석에 초점을 맞췄기에, 오래된 데이터에 대한 걱정이 줄어듭니다. )</li>
  <li>동일한 쿼리가 데이터웨어 하우스에서 실행되는 경우가 많으면 계산 비용이 합산 될 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="구체화-뷰-생성-방법--materialized-views-">구체화 뷰 생성 방법 ( materialized views )</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">my_mv</span> <span class="k">AS</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">existing_table</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">REFRESH</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">my_mv</span><span class="p">;</span>
</code></pre></div></div>

<p>SQL문에 MATERIALIZED를 지정하는 것을 제외하고는, 비 구체화 된 뷰와 동일합니다.</p>

<p>갱신하는 코드는 cron을 이용합니다.</p>

<p><br /></p>

<h4 id="managing-dependencies">Managing dependencies</h4>

<p>비 구체화 된 뷰와 달리, 종속성이있을 때, 구체화 된 뷰를 새로 관리해야합니다.</p>

<p align="center"><img src="/images/post_img/design23.png" /></p>

<p>Y는 쿼리에서 X를 사용합니다. 따라서, Y는 X에 따라 달라집니다.</p>

<p>X에 더많은 시간이 소요되는 쿼리가 있다고 가정할 때, X의 새로 고침이 완료되기 전에 Y가 새로고쳐지면, Y는 오래된 데이터를 가지게 됩니다.</p>

<p>이렇게 하면 뷰를 새로 고칠 때 종속성 체인이 생성됩니다. ( 새로 고침시기를 예약하는 것은 간단하지 않습니다. ) - 쿼리 시간과 종속성을 고려할 때 동시에 고치는 것은 가장 효율적이지 않습니다.</p>

<p>이를 위해서는 Airflow와 같은 방향성 비순환 그래프를 사용하면 됩니다.</p>

<p><br /></p>

<h2 id="4-database-management">4. Database Management</h2>

<p><br /></p>

<h4 id="데이터베이스-역할">데이터베이스 역할</h4>

<ul>
  <li>규칙은 데이터베이스 액세스 권한을 관리하는데 사용됩니다.</li>
  <li>데이터 베이스 역할은 다음 정보를 포함하는 엔티티입니다.
    <ul>
      <li>로그인 할 수 있는지?, 데이터베이스를 생성할 수 있는지?, 테이블을 작성할 수 있는지?</li>
      <li>암호와 같은 클라이어늩 인증 시셈과 상호 작용</li>
    </ul>
  </li>
  <li>역할은 한 명 이상의 사용자에게 할당 될 수 있습니다.</li>
  <li>역할은 전역이므로 클러스터의 모든 개별 데이터베이스에서 역할을 참조 할 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="create-role">Create role</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">ROLE</span> <span class="n">data_analyst</span><span class="p">;</span>
</code></pre></div></div>

<p>위의 명령을 사용해서 data_analyst 역할을 생성 할 수 있습니다.</p>

<p><br /></p>

<p>역할을 생성 할 때 이 정보의 일부를 설정할 수도 있습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">ROLE</span> <span class="n">intern</span> <span class="k">WITH</span> <span class="n">PASSWORD</span> <span class="s1">'PasswordForIntern'</span> <span class="k">VALID</span> <span class="k">UNTIL</span> <span class="s1">'2020-01-01'</span><span class="p">;</span>
</code></pre></div></div>

<p>위와 같이 역할을 생성하고 유효 날짜 속성을 지정 합니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">ROLE</span> <span class="k">admin</span> <span class="k">CREATEDB</span><span class="p">;</span>
</code></pre></div></div>

<p>다음 속성을 이용해서 관리자 역할을 생성합니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">ROLE</span> <span class="k">admin</span> <span class="n">CREATEROLE</span><span class="p">;</span>
</code></pre></div></div>

<p>ALTER 키워드를 이용해서 관리자 역할을 만들 수 있습니다.</p>

<p><br /></p>

<h4 id="승인-거절-roles">승인, 거절 roles</h4>

<p>특정 액세스 제어 권한을 부여하려면 GRANT 및 REVOKE를 사용합니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="k">UPDATE</span> <span class="k">ON</span> <span class="n">ratings</span> <span class="k">TO</span> <span class="n">data_analyst</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">REVOKE</span> <span class="k">UPDATE</span> <span class="k">ON</span> <span class="n">ratings</span> <span class="k">FROM</span> <span class="n">data_analyst</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="users-and-groups">Users and groups</h4>

<p>역할은 사용자 역할 또는 그룹 역할이 될 수 있습니다.</p>

<ul>
  <li>User roles</li>
  <li>Group roles</li>
</ul>

<p>역할은 다른 역할의 구성원 일 수 있으며 더 큰 역할을 그룹이라고 합니다.</p>

<p align="center"><img src="/images/post_img/design24.png" /></p>

<p><br /></p>

<h5 id="group-role">Group role</h5>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">ROLE</span> <span class="n">data_analyst</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<h5 id="user-role">User role</h5>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">ROLE</span> <span class="n">alex</span> <span class="k">WITH</span> <span class="n">PASSWORD</span> <span class="s1">'PasswordForIntern'</span> <span class="k">VALID</span> <span class="k">UNTIL</span> <span class="s1">'2020-01-01'</span><span class="p">;</span>
</code></pre></div></div>

<p>data_analyst 역할을 그룹 역할로 생각하면 모든 데이터 분석가가 동일한 수준에 액세스 권한을 갖기를 원합니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="n">data_analyst</span> <span class="k">TO</span> <span class="n">alex</span><span class="p">;</span>
</code></pre></div></div>

<p>사용자 역할 alex를 그룹 역할 data_analyst에 추가하려면 위의 코드처럼 사용합니다.</p>

<p><br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">REVOKE</span> <span class="n">data_analyst</span> <span class="k">FROM</span> <span class="n">alex</span><span class="p">;</span>
</code></pre></div></div>

<p>제거하는 것은 REVOKE를 사용하면 됩니다.</p>

<p><br /></p>

<h4 id="roles의-장단점">roles의 장단점</h4>

<p>장점</p>

<ul>
  <li>유저가 사라져도, 역할은 살아있다.</li>
  <li>유저가 계정을 얻기 전에도 만들 수 있다.</li>
  <li>데이터베이스 관리자는 시간을 절약 할 수 있다.</li>
</ul>

<p><br /></p>

<p>단점</p>

<ul>
  <li>역할은 개인에게 너무 많은 엑세스 권한을 부여합니다.</li>
  <li>역할 및 액세스 수준에 주의하고 염두에 두어야합니다.</li>
</ul>

<p><br /></p>

<h4 id="partition-분할">Partition (분할)</h4>

<ul>
  <li>테이블이 커지면 쿼리가 느려지는 경향이 있습니다. 인덱스를 올바르게 설정 한 경우에도 이러한 인덱스가 너무 커져서 메모리에 맞지 않을 수 있습니다.</li>
  <li>특정 시점에서 테이블을 여러 개의 작은 부분으로 분할하는 것이 합리적 일 수 있습니다.</li>
</ul>

<p><br /></p>

<h4 id="data-modeling-refresher">Data modeling refresher</h4>

<p>데이터 모델링을 보면,</p>

<ul>
  <li>Conceptual data model</li>
  <li>Logical data model</li>
</ul>

<p>논리적 데이터 모델은, 액세스하거나 업데이트 할 데이터는 여전히 동일합니다. ( 차이점은 데이터를 여러 물리적 엔티티에 배포한다는 것입니다. )</p>

<ul>
  <li>Physical data model</li>
</ul>

<p>파티셔닝은 위 세개의 모델 중 3. Physical data model에 적합합니다.</p>

<p><br /></p>

<h4 id="vertical-partitioning">Vertical partitioning</h4>

<p>파티셔닝 유형은 두가지의 파티셔닝이있는데</p>

<p align="center"><img src="/images/post_img/design25.png" /></p>

<p>위의 분할은 수직 분할입니다. 이전에 정규화로 분할된 상태에서 수직 분할은 한단계 더 나아가 테이블을 분할합니다.</p>

<p>이미 완전히 정규화 된 경우에도 열에 의해 수직으로 분할됩니다.</p>

<p align="center"><img src="/images/post_img/design26.png" /></p>

<p>분할 뒤, 공유 키를 통해 연결 할 수 있습니다. 긴텍스트를 포함한 열을 검색에 사용하지 않는다면, 더 적은 데이터를 스캔하므로 쿼리시간이 향상됩니다.</p>

<p><br /></p>

<h4 id="horizontal-partitioning">Horizontal partitioning</h4>

<p align="center"><img src="/images/post_img/design27.png" /></p>

<p>수평 분할은 다음과 같이 row를 기준으로 자릅니다.</p>

<p align="center"><img src="/images/post_img/design28.png" /></p>

<p><br /></p>

<h4 id="수평-분할의-장단점">수평 분할의 장단점</h4>

<p>장점</p>

<ul>
  <li>인덱스의 많이 사용되는 부분이 메모리에 들어갈 가능성을 높입니다.</li>
  <li>거의 액세스하지 않는 파티션을 더 느린 미디어로 이동할 수도 있습니다.</li>
  <li>OLAP는 OLTP 의 이점을 누릴수 있습니다.</li>
</ul>

<p>단점</p>

<ul>
  <li>새 테이블을 만드록 데이터를 복사하는 등의 과정이 존재한다.</li>
  <li>항상 동일한 유형을 설정할 수 없다. ( 프라이머리 키로 한계가 있다? )</li>
</ul>

<p><br /></p>

<h4 id="relation-to-sharding">Relation to sharding</h4>

<p>파티셔닝을 한 단계 더 나아가 여러 머신에 분산 시킬 수 있습니다.</p>

<p align="center"><img src="/images/post_img/design29.png" /></p>

<p>수평 분할을 적용하여 여러 컴퓨터에 테이블을 분산하는 것을 샤딩이라고하는데 이것을 이용하여 대규모 병렬 처리를 가능하게 합니다.</p>

<p><br /></p>

<h4 id="what-is-data-integration">What is data integration</h4>

<p>데이터 통합은 다양한 소스, 형식, 사용자에게 해당 데이터에 대한 번역되고 통합된 보기를 제공하는 기술입니다.</p>

<p><br /></p>

<h4 id="business-case-example">Business case example</h4>

<ul>
  <li>360 -degree 고객 관측</li>
  <li>기업 인수</li>
  <li>레거시 시스템 ( 과거 오래된 데이터 )</li>
</ul>

<p>다음과 같은 케이스들로 인해 데이터를 통합할 수 있습니다.</p>

<p>최종 목적은, 통합 데이터 모델을 사용하여 대시보드를 제작하는 것입니다. ( 일일 판매 그래프, 추천 엔진 )</p>

<p>최종 데이터 모델은 사용 사례에 맞게 충분히 빨라야합니다.</p>

<p>필요한 정보는 이러한 데이터 소스에 보관됩니다.</p>

<p align="center"><img src="/images/post_img/design30.png" /></p>

<p><br /></p>

<p>얼마나 자주 데이터를 업데이트 할 것인가? (경우에 따라 적절하게 설정해야함)</p>

<p>소스는 서로 다른 형식을 가지므로, 통합할 수 있는지 확인해야합니다. (트랜스폼 과정 필요)</p>

<p><br /></p>

<h4 id="데이터-병합-툴-선택">데이터 병합 툴 선택</h4>

<ul>
  <li>모든 데이터 소스에 연결할 수 있을만큼 유연성이 있는지 확인</li>
  <li>신뢰할 수 있는지 ( 유지 관리 가능 한지 )</li>
  <li>데이터 볼륨과 소스의 증가에 대응 할수 있는지 ( 확장성 )</li>
</ul>

<p><br /></p>

<h4 id="경고알림">경고(알림)</h4>

<p>데이터가 ETL과정 중 손상되면 시스템에 의해 알아야 합니다.</p>

<p><br /></p>

<h4 id="보안">보안</h4>

<p>데이터 액세스가 제한되는 경우 통합 데이터 모델에서 제한을 유지해야합니다.</p>

<p><br /></p>

<h4 id="데이터-거버넌스">데이터 거버넌스</h4>

<p>데이터 거버넌스 목적을 위해 계보를 고려해야함</p>

<p>감사를 수행하려면 데이터의 출처와 사용 위치를 항상 알아야합니다.</p>

<p><br /></p>

<h4 id="database-management-system-dbms">Database Management System (DBMS)</h4>

<ul>
  <li>DBMS는 데이터베이스를 만들고 유지하기 위한 시스템 소프트웨어입니다.</li>
  <li>DBMS는 데이터베이스 스키마를 정의하는 세가지 중요한 측면을 관리합니다.
    <ul>
      <li>Data</li>
      <li>Database schema</li>
      <li>Database engine</li>
    </ul>
  </li>
  <li>DBMS는 데이터베이스와 최종 사용자 또는 응용 프로그램 간의 인터페이스 역할을 합니다.</li>
</ul>

<p align="center"><img src="/images/post_img/design31.png" /></p>

<p><br /></p>

<h4 id="dbms-types">DBMS types</h4>

<ul>
  <li>DBMS 선택은 필요한 데이터베이스 유형에 따라 결정됩니다.</li>
  <li>Two types:
    <ul>
      <li>SQL DBMS</li>
      <li>NoSQL DBMS</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="sql-dbms">SQL DBMS</h4>

<ul>
  <li>관계형 데이터베이스라고 불림</li>
  <li>시스템은 관계형 데이터 모델을 기반으로 하는 일종의 DBMS입니다.</li>
  <li>RDBMS는 일반적으로 데이터 관리 및 엑세스를 위한 SQL을 사용합니다.</li>
  <li>SQL Server, PostgerSQL, ORACLE</li>
  <li>RDBMS를 고려하는 두가지 이유
    <ul>
      <li>미리 정의된 스키마의 이점을 얻을 수 있는 구조화되고 변경되지 않은 데이터로 작업할 때</li>
      <li>회계 시스템같이 오류의 여지를 남기지 않고 모든 데이터가 일관성이 있어야하는 경우</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="nosql-dbms">NoSQL DBMS</h4>

<ul>
  <li>관계형 데이터베이스보다 훨씬 덜 구조적이며 테이블 중심이 아닌 문서 중심</li>
  <li>NoSQL 데이터베이스의 데이터는 잘 정의된 행과 열에 맞지 않아도됩니다.</li>
  <li>NoSQL은 명확한 스키마 정의없이 빠른 데이터 증가를 경험하는 기업에게 적합</li>
  <li>NoSQL은 SQL DBMS보다 휠씬 더 많은 유연성을 제공하며 대량의 데이터를 분석하거나 다양한 데이터 구조를 관리해야하는 기업에게 적합</li>
  <li>key-value store, documents store, columnar database, graph database</li>
</ul>

<p><br /></p>

<h4 id="nosql---key-value-store">NoSQL - key-value store</h4>

<p align="center"><img src="/images/post_img/design32.png" /></p>

<ul>
  <li>key-value 데이터베이스는 키와 밸류의 조합을 저장합니다.</li>
  <li>키는 관련 값을 검색하는 고유 식별자 역할을 하며, 밸류는 정수 또는 문자열과 같은 간단한 개체부터 JSON 구조와 같은 더 복잡한 개체까지 다양합니다.</li>
  <li>웹 애플리케이션에서 세션 정보를 관리하늗네 자주 사용</li>
  <li>대표적으로 redis가 있음</li>
</ul>

<p><br /></p>

<h4 id="nosql---document-store">NoSQL - document store</h4>

<p align="center"><img src="/images/post_img/design33.png" /></p>

<ul>
  <li>Document store는 각각 값에 해당하는 키로 구성된다는 점에서 키밸류와 유사</li>
  <li>차이점은, 저장된 값이 문서구조</li>
  <li>블로그 및 비디오 플랫폼과 같은 콘텐츠 관리 응용프로그램을 위한 훌륭한 선택임</li>
  <li>애플리케이션이 추적하는 각 엔티티는 단일 문서로 저장 할 수 있음</li>
  <li>대표적으로 MongoDB</li>
</ul>

<p><br /></p>

<h4 id="nosql---columnar-database">NoSQL - columnar database</h4>

<p align="center"><img src="/images/post_img/design34.png" /></p>

<ul>
  <li>열을 테이블로 그룹화하는 대신 데이터베이스는 각 열을 시스템 저장소의 별도 파일에 저장</li>
  <li>확장성과 규모가 더 빠른 데이터베이스가 가능</li>
  <li>속도가 중요한 빅 데이터 분석을 위해 컬럼 형 데이터베이스 이용</li>
  <li>대표적으로 Cassandra</li>
</ul>

<p><br /></p>

<h4 id="nosql---graph-database">NoSQL - graph database</h4>

<p align="center"><img src="/images/post_img/design35.png" /></p>

<ul>
  <li>데이터는 서로 연결되어 있고 그래프로 표현됨 ( 다소 복잡 )</li>
  <li>대부분의 소셜 네트워크에서 사용되며, 행동에 따라 무엇이든 추천하는 웹사이트 많습니다.</li>
  <li>대표적으로 neo4j</li>
</ul>

<p><br /></p>

:ET